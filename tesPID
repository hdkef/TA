#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27,16,2);

int firing_pin = 3;
int zero_cross = 8;
//Variables
int last_CH1_state = 0;
bool zero_cross_detected = false;
int firing_delay = 7400;

//////////////////////////////////////////////////////
int maximum_firing_delay = 7400;
//PID variables
float PID_error = 0;
float previous_error = 0;
float elapsedTime, Time, timePrev;
long PID_value = 0;

float real_temperature = 0.0;
int range_max = 100;

int sensor_pin = A1;

int setpoint = 50;
int kp = 2900;   int ki = 0;   int kd = 0;
long PID_p = 0;    long PID_i = 0;    long PID_d = 0;

void setup() {
  Serial.begin(9600);
  // put your setup code here, to run once:
  pinMode (firing_pin,OUTPUT); 
  pinMode (zero_cross,INPUT); 
  PCICR |= (1 << PCIE0);    //enable PCMSK0 scan                                                 
  PCMSK0 |= (1 << PCINT0);  //Set pin D8 (zero cross input) trigger an interrupt on state change.    
  lcd.begin();       //Start the LC communication
  lcd.backlight();  //Turn on backlight for LCD
}

float readRTD() {
    float analog_raw = analogRead(sensor_pin);
    float voltage_raw = ((analog_raw * 5.0 / 1024.0) - 1.0);
    float temp_celcius = voltage_raw * range_max / 4.0;
    return temp_celcius;
}

void loop() {             //Increase the previous time for next loop
    real_temperature = readRTD();  //get the real temperature in Celsius degrees

    PID_error = setpoint - real_temperature;        //Calculate the pid ERROR
    
    if(PID_error > 30)                              //integral constant will only affect errors below 30ºC             
    {PID_i = 0;}
    
    PID_p = kp * PID_error;                         //Calculate the P value
    PID_i = PID_i + (ki * PID_error);               //Calculate the I value
    timePrev = Time;                    // the previous time is stored before the actual time read
    Time = millis();                    // actual time read
    elapsedTime = (Time - timePrev) / 1000;   
    PID_d = kd *((PID_error - previous_error)/elapsedTime);  //Calculate the D value
    PID_value = PID_p + PID_i + PID_d;
    if(PID_value < 0)
    {      PID_value = 0;       }
    if(PID_value > 7400)
    {      PID_value = 7400;    }
    //Printe the values on the LCD
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Set: ");
    lcd.setCursor(5,0);
    lcd.print(setpoint);
    lcd.setCursor(0,1);
    lcd.print("Real temp: ");
    lcd.setCursor(11,1);
    lcd.print(real_temperature);
    previous_error = PID_error;
    Serial.println("PID error");
    Serial.println(PID_error);
    Serial.println("P val");
    Serial.println(PID_p);
    Serial.println("I val");
    Serial.println(PID_i);
    Serial.println("D val");
    Serial.println(PID_d);
    Serial.println("PID value");
    Serial.println(PID_value);
  

    if (zero_cross_detected)     
    {
      delayMicroseconds(maximum_firing_delay - PID_value); //This delay controls the power
      digitalWrite(firing_pin,HIGH);
      delayMicroseconds(100);
      digitalWrite(firing_pin,LOW);
      zero_cross_detected = false;
    }
}

ISR(PCINT0_vect){
  ///////////////////////////////////////Input from optocoupler
  if(PINB & B00000001){            //We make an AND with the state register, We verify if pin D8 is HIGH???
    if(last_CH1_state == 0){       //If the last state was 0, then we have a state change...
      zero_cross_detected = true;  //We have detected a state change! We need both falling and rising edges
    }
  }
  else if(last_CH1_state == 1){    //If pin 8 is LOW and the last state was HIGH then we have a state change      
    zero_cross_detected = true;    //We haev detected a state change!  We need both falling and rising edges.
    last_CH1_state = 0;            //Store the current state into the last state for the next loop
  }
}#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27,16,2);

int firing_pin = 3;
int zero_cross = 8;
//Variables
int last_CH1_state = 0;
bool zero_cross_detected = false;
int firing_delay = 7400;

//////////////////////////////////////////////////////
int maximum_firing_delay = 7400;
//PID variables
float PID_error = 0;
float previous_error = 0;
float elapsedTime, Time, timePrev;
long PID_value = 0;

float real_temperature = 0.0;
int range_max = 100;

int sensor_pin = A1;

int setpoint = 50;
int kp = 2900;   int ki = 0;   int kd = 0;
long PID_p = 0;    long PID_i = 0;    long PID_d = 0;

void setup() {
  Serial.begin(9600);
  // put your setup code here, to run once:
  pinMode (firing_pin,OUTPUT); 
  pinMode (zero_cross,INPUT); 
  PCICR |= (1 << PCIE0);    //enable PCMSK0 scan                                                 
  PCMSK0 |= (1 << PCINT0);  //Set pin D8 (zero cross input) trigger an interrupt on state change.    
  lcd.begin();       //Start the LC communication
  lcd.backlight();  //Turn on backlight for LCD
}

float readRTD() {
    float analog_raw = analogRead(sensor_pin);
    float voltage_raw = ((analog_raw * 5.0 / 1024.0) - 1.0);
    float temp_celcius = voltage_raw * range_max / 4.0;
    return temp_celcius;
}

void loop() {             //Increase the previous time for next loop
    real_temperature = readRTD();  //get the real temperature in Celsius degrees

    PID_error = setpoint - real_temperature;        //Calculate the pid ERROR
    
    if(PID_error > 30)                              //integral constant will only affect errors below 30ºC             
    {PID_i = 0;}
    
    PID_p = kp * PID_error;                         //Calculate the P value
    PID_i = PID_i + (ki * PID_error);               //Calculate the I value
    timePrev = Time;                    // the previous time is stored before the actual time read
    Time = millis();                    // actual time read
    elapsedTime = (Time - timePrev) / 1000;   
    PID_d = kd *((PID_error - previous_error)/elapsedTime);  //Calculate the D value
    PID_value = PID_p + PID_i + PID_d;
    if(PID_value < 0)
    {      PID_value = 0;       }
    if(PID_value > 7400)
    {      PID_value = 7400;    }
    //Printe the values on the LCD
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Set: ");
    lcd.setCursor(5,0);
    lcd.print(setpoint);
    lcd.setCursor(0,1);
    lcd.print("Real temp: ");
    lcd.setCursor(11,1);
    lcd.print(real_temperature);
    previous_error = PID_error;
    Serial.println("PID error");
    Serial.println(PID_error);
    Serial.println("P val");
    Serial.println(PID_p);
    Serial.println("I val");
    Serial.println(PID_i);
    Serial.println("D val");
    Serial.println(PID_d);
    Serial.println("PID value");
    Serial.println(PID_value);
  

    if (zero_cross_detected)     
    {
      delayMicroseconds(maximum_firing_delay - PID_value); //This delay controls the power
      digitalWrite(firing_pin,HIGH);
      delayMicroseconds(100);
      digitalWrite(firing_pin,LOW);
      zero_cross_detected = false;
    }
}

ISR(PCINT0_vect){
  ///////////////////////////////////////Input from optocoupler
  if(PINB & B00000001){            //We make an AND with the state register, We verify if pin D8 is HIGH???
    if(last_CH1_state == 0){       //If the last state was 0, then we have a state change...
      zero_cross_detected = true;  //We have detected a state change! We need both falling and rising edges
    }
  }
  else if(last_CH1_state == 1){    //If pin 8 is LOW and the last state was HIGH then we have a state change      
    zero_cross_detected = true;    //We haev detected a state change!  We need both falling and rising edges.
    last_CH1_state = 0;            //Store the current state into the last state for the next loop
  }
}
