/*    Max6675 Module  ==>   Arduino
 *    CS              ==>     D10
 *    SO              ==>     D9
 *    SCK             ==>     D13
 *    Vcc             ==>     Vcc (5v)
 *    Gnd             ==>     Gnd      */

const long timer = 600000;

//LCD config
#include <Wire.h> 
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27,16,2);  //sometimes the adress is not 0x27. Change to 0x3f if it dosn't work.
#include <neotimer.h>
Neotimer mytimer = Neotimer(timer);

/*    i2c LCD Module  ==>   Arduino
 *    SCL             ==>     A5
 *    SDA             ==>     A4
 *    Vcc             ==>     Vcc (5v)
 *    Gnd             ==>     Gnd      */

//Inputs and outputs
int firing_pin = 3;
int zero_cross = 53;
int sensor_pin = A0;
int lamp_pin = 28;
float range_max = 150.0;



//Variables
int last_CH1_state = 0;
bool zero_cross_detected = false;
bool lamp_status = true;


//////////////////////////////////////////////////////
int maximum_firing_delay = 7400;
/*Later in the code you will se that the maximum delay after the zero detection
 * is 7400. Why? Well, we know that the 220V AC voltage has a frequency of around 50-60HZ so
 * the period is between 20ms and 16ms, depending on the country. We control the firing
 * delay each half period so each 10ms or 8 ms. To amke sure we wont pass thsoe 10ms, I've made tests
 * and the 7400us or 7.4ms was a good value. Measure your frequency and chande that value later */
//////////////////////////////////////////////////////

unsigned long previousMillis = 0; 
unsigned long currentMillis = 0;
int temp_read_Delay = 500;
float real_temperature = 0.0;
float setpoint = 110.0;
bool evap = true;
int sample_count = 0;
int sample_min = 5;
float sample_err = 1.0;
bool timer_start = false;

//PID variables
float PID_error = 0.0;
float previous_error = 0.0;
float elapsedTime, Time, timePrev;
long PID_value = 0;
//PID constants
int kp = 2000;   int ki= 0;   int kd = 0;
long PID_p = 0;    long PID_i = 0;    long PID_d = 0;


void setup() {
  //Define the pins
  Serial.begin(9600);
  pinMode(firing_pin,OUTPUT);
  pinMode(lamp_pin,OUTPUT);  
  pinMode(zero_cross,INPUT);  
  PCICR |= (1 << PCIE0);    //enable PCMSK0 scan                                                 
  PCMSK0 |= (1 << PCINT0);  //Set pin 53 (zero cross input) trigger an interrupt on state change.
  lcd.begin();       //Start the LC communication
  lcd.backlight();  //Turn on backlight for LCD
  digitalWrite(lamp_pin,LOW);
}

float readRTD() {
    float analog_raw = analogRead(sensor_pin);
    float voltage_raw = ((analog_raw * 5.0 / 1024.0) - 0.6624);
    float temp_celcius = voltage_raw * range_max / 2.9376;
    return temp_celcius;
}

void loop() {    
    currentMillis = millis();           //Save the value of time before the loop
   /*  We create this if so we will read the temperature and change values each "temp_read_Delay"
    *  value. Change that value above iv you want. The MAX6675 read is slow. Tha will affect the
    *  PID control. I've tried reading the temp each 100ms but it didn't work. With 500ms worked ok.*/
  if(currentMillis - previousMillis >= temp_read_Delay){
    previousMillis += temp_read_Delay;              //Increase the previous time for next loop
    real_temperature = readRTD();

    PID_error = setpoint - real_temperature;        //Calculate the pid ERROR
    Serial.println("PID err");
    Serial.println(PID_error);

    if (PID_error <= sample_err && evap == true && timer_start == false){
      Serial.println("count");
      Serial.println(sample_count);
      sample_count++;
      }

      if (sample_count > sample_min && evap == true){
        Serial.println("sample count > sample min");
        if (timer_start == false){
          Serial.println("timer start");
          timer_start = true;
          mytimer.start();
        }
      }

    if (timer_start == true){
      if (mytimer.done()){
        evap = false;
        timer_start = false;
      }
    }
    
    if(PID_error > 30)                              //integral constant will only affect errors below 30ÂºC             
    {PID_i = 0;}
    
    PID_p = kp * PID_error;                         //Calculate the P value
    PID_i = PID_i + (ki * PID_error);               //Calculate the I value
    timePrev = Time;                    // the previous time is stored before the actual time read
    Time = millis();                    // actual time read
    elapsedTime = (Time - timePrev) / 1000;   
    PID_d = kd*((PID_error - previous_error)/elapsedTime);  //Calculate the D value
    PID_value = PID_p + PID_i + PID_d;                      //Calculate total PID value

    //We define firing delay range between 0 and 7400. Read above why 7400!!!!!!!
    if(PID_value < 0)
    {      PID_value = 0;       }
    if(PID_value > maximum_firing_delay)
    {      PID_value = maximum_firing_delay;    }
    //Printe the values on the LCD
    if (evap == true){
      lcd.setCursor(0,0);
      lcd.print("Temp: ");
      lcd.setCursor(5,0);
      lcd.print(real_temperature);
      if (timer_start == false){
        lcd.setCursor(0,1);
        lcd.print("sample: ");
        lcd.setCursor(8,1);
        lcd.print(sample_count);
      }
      else{
          lcd.setCursor(0,1);
          lcd.print("TIMER ON ");
        }
    }
    else{
      lcd.setCursor(0,0);
      lcd.print("Evap done");
      lcd.setCursor(0,1);
      lcd.print("Pls Switch Off");
    }
    previous_error = PID_error; //Remember to store the previous error.
  }

  //If the zero cross interruption was detected we create the 100us firing pulse  
  if (zero_cross_detected && evap == true)     
    {
      delayMicroseconds(maximum_firing_delay - PID_value); //This delay controls the power
      digitalWrite(firing_pin,HIGH);
      delayMicroseconds(100);
      digitalWrite(firing_pin,LOW);
      zero_cross_detected = false;
    } 
  else if (zero_cross_detected && evap == false){
    if (lamp_status == true){
      lamp_status = false;
      digitalWrite(lamp_pin,HIGH); //matiin lampu
    }
    delayMicroseconds(maximum_firing_delay); //This delay controls the power
    digitalWrite(firing_pin,LOW);
    delayMicroseconds(100);
    digitalWrite(firing_pin,LOW);
    zero_cross_detected = false;
  }
}
//End of void loop
// |
// |
// |
// v
//See the interruption vector
//This is the interruption routine (pind D8(zero cross), D11(increase) and D12(decrease))
//----------------------------------------------

ISR(PCINT0_vect){
  ///////////////////////////////////////Input from optocoupler
  if(PINB & B00000001){            //We make an AND with the state register, We verify if pin D8 is HIGH???
    if(last_CH1_state == 0){       //If the last state was 0, then we have a state change...
      zero_cross_detected = true;  //We have detected a state change! We need both falling and rising edges
      last_CH1_state = 1;
    }
  }
  else if(last_CH1_state == 1){    //If pin 8 is LOW and the last state was HIGH then we have a state change      
    zero_cross_detected = true;    //We haev detected a state change!  We need both falling and rising edges.
    last_CH1_state = 0;            //Store the current state into the last state for the next loop
    }
}
//End of interruption vector for pins on port B: D8-D13
